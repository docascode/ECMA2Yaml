<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>CatLibrary</name>
  </assembly>
  <members>
    <member name="T:CatLibrary.Cat`2">
      <summary>
        <para>Here's main class of this <i>Demo</i>.</para>
        <para>You can see mostly type of article within this class and you for more detail, please see the remarks.</para>
        <para />
        <para>this class is a template class. It has two Generic parameter. they are: <typeparamref name="T" /> and <typeparamref name="K" />.</para>
        <para>The extension method of this class can refer to <see cref="T:CatLibrary.ICatExtension" /> class</para>
      </summary>
      <typeparam name="T">This type should be class and can new instance.</typeparam>
      <typeparam name="K">This type is a struct type, class type can't be used for this parameter.</typeparam>
    </member>
    <member name="E:CatLibrary.Cat`2.CatLibrary#ICat#eat" />
    <member name="E:CatLibrary.Cat`2.ownEat">
      <summary>
            Eat event of this cat</summary>
    </member>
    <member name="F:CatLibrary.Cat`2.isHealthy">
      <summary>
            Field with attribute.</summary>
    </member>
    <member name="M:CatLibrary.Cat`2.#ctor">
      <summary>
            Default constructor.</summary>
    </member>
    <member name="M:CatLibrary.Cat`2.#ctor(`0)">
      <summary>
            Constructor with one generic parameter.</summary>
      <param name="ownType">This parameter type defined by class.</param>
    </member>
    <member name="M:CatLibrary.Cat`2.#ctor(System.String,System.Int32@,System.String,System.Boolean)">
      <summary>
            It's a complex constructor. The parameter will have some attributes.</summary>
      <param name="nickName">it's string type.</param>
      <param name="age">It's an out and ref parameter.</param>
      <param name="realName">It's an out paramter.</param>
      <param name="isHealthy">It's an in parameter.</param>
    </member>
    <member name="M:CatLibrary.Cat`2.CalculateFood(System.DateTime)">
      <summary>
            It's a method with complex return type.</summary>
      <param name="date">Date time to now.</param>
      <returns>It's a relationship map of different kind food.</returns>
    </member>
    <member name="M:CatLibrary.Cat`2.CatchJerry">
      <summary>
            This one can't.</summary>
    </member>
    <member name="M:CatLibrary.Cat`2.CatchJerry(System.Boolean)">
      <summary>
            If you force it, maybe it can.</summary>
      <param name="force" />
    </member>
    <member name="M:CatLibrary.Cat`2.CatLibrary#IAnimal#Eat">
      <summary>
            EII method.</summary>
    </member>
    <member name="M:CatLibrary.Cat`2.CatLibrary#IAnimal#Eat(System.String)">
      <summary>
            Implementation of Eat(food)</summary>
      <param name="food">Food to eat</param>
    </member>
    <member name="M:CatLibrary.Cat`2.CatLibrary#IAnimal#Eat``1(``0)">
      <summary>
            EII template method.</summary>
      <param name="a">Tool name.</param>
      <typeparam name="Tool">Tool for eat.</typeparam>
    </member>
    <member name="M:CatLibrary.Cat`2.Equals(System.Object)">
      <summary>
            Override the method of <c>Object.Equals(object obj).</c></summary>
      <param name="obj">Can pass any class type.</param>
      <returns>The return value tell you whehter the compare operation is successful.</returns>
    </member>
    <member name="M:CatLibrary.Cat`2.GetTailLength(System.Int32*,System.Object[])">
      <summary>
            It's an <c>unsafe</c> method.
            As you see, <paramref name="catName" /> is a pointer, so we need to add <languageKeyword>unsafe</languageKeyword> keyword.</summary>
      <param name="catName">Thie represent for cat name length.</param>
      <param name="parameters">Optional parameters.</param>
      <returns>Return cat tail's length.</returns>
    </member>
    <member name="M:CatLibrary.Cat`2.Jump(`0,`1,System.Boolean@)">
      <summary>
            This method have attribute above it.</summary>
      <param name="ownType">Type come from class define.</param>
      <param name="anotherOwnType">Type come from class define.</param>
      <param name="cheat">Hint whether this cat has cheat mode.</param>
      <exception cref="T:System.ArgumentException">This is an argument exception</exception>
    </member>
    <member name="M:CatLibrary.Cat`2.op_Addition(CatLibrary.Cat{`0,`1},System.Int32)">
      <summary>
            Addition operator of this class.</summary>
      <param name="lsr">...</param>
      <param name="rsr">~~~</param>
      <returns>Result with <i>int</i> type.</returns>
    </member>
    <member name="M:CatLibrary.Cat`2.op_Explicit(CatLibrary.Cat{`0,`1})~CatLibrary.Tom">
      <summary>
            Expilicit operator of this class.
            <para>It means this cat can evolve to change to Tom. Tom and Jerry.</para></summary>
      <param name="src">Instance of this class.</param>
      <returns>Advanced class type of cat.</returns>
    </member>
    <member name="M:CatLibrary.Cat`2.op_Subtraction(CatLibrary.Cat{`0,`1},System.Int32)">
      <summary>
            Similar with operaotr +, refer to that topic.</summary>
      <param name="lsr" />
      <param name="rsr" />
    </member>
    <member name="P:CatLibrary.Cat`2.Age">
      <summary>
            Hint cat's age.</summary>
    </member>
    <member name="P:CatLibrary.Cat`2.CatLibrary#IAnimal#Item(System.Int32)">
      <summary>
            EII index.</summary>
      <param name="a">Cat's number.</param>
      <returns>Cat's name.</returns>
    </member>
    <member name="P:CatLibrary.Cat`2.Item(System.String)">
      <summary>
            This is index property of Cat. You can see that the visibility is different between <c>get</c> and <c>set</c> method.</summary>
      <param name="a">Cat's name.</param>
      <returns>Cat's number.</returns>
    </member>
    <member name="P:CatLibrary.Cat`2.Name">
      <summary>
            EII property.</summary>
    </member>
    <member name="T:CatLibrary.CatException`1">
      <typeparam name="T" />
    </member>
    <member name="M:CatLibrary.CatException`1.#ctor" />
    <member name="T:CatLibrary.Complex`2">
      <typeparam name="T" />
      <typeparam name="J" />
    </member>
    <member name="M:CatLibrary.Complex`2.#ctor" />
    <member name="T:CatLibrary.Complex`2.ComplexFlags">
      <typeparam name="T" />
      <typeparam name="J" />
    </member>
    <member name="F:CatLibrary.Complex`2.ComplexFlags.None" />
    <member name="F:CatLibrary.Complex`2.ComplexFlags.SkipInitialPreparation" />
    <member name="F:CatLibrary.Complex`2.ComplexFlags.StickyWrite" />
    <member name="T:CatLibrary.FakeDelegate`1">
      <summary>
            Fake delegate</summary>
      <param name="num">Fake para</param>
      <param name="name">Fake para</param>
      <param name="scores">Optional Parameter.</param>
      <typeparam name="T">Fake para</typeparam>
      <returns>Return a fake number to confuse you.</returns>
    </member>
    <member name="T:CatLibrary.IAnimal">
      <summary>
            This is basic interface of all animal.</summary>
    </member>
    <member name="M:CatLibrary.IAnimal.Eat">
      <summary>
            Animal's eat method.</summary>
    </member>
    <member name="M:CatLibrary.IAnimal.Eat(System.String)">
      <summary>
            Feed the animal with some food</summary>
      <param name="food">Food to eat</param>
    </member>
    <member name="M:CatLibrary.IAnimal.Eat``1(``0)">
      <summary>
            Overload method of eat. This define the animal eat by which tool.</summary>
      <param name="tool">Tool name.</param>
      <typeparam name="Tool">It's a class type.</typeparam>
    </member>
    <member name="P:CatLibrary.IAnimal.Item(System.Int32)">
      <summary>
            Return specific number animal's name.</summary>
      <param name="index">Animal number.</param>
      <returns>Animal name.</returns>
    </member>
    <member name="P:CatLibrary.IAnimal.Name">
      <summary>
            Name of Animal.</summary>
    </member>
    <member name="T:CatLibrary.ICat">
      <summary>
            Cat's interface</summary>
    </member>
    <member name="E:CatLibrary.ICat.eat">
      <summary>
            eat event of cat. Every cat must implement this event.</summary>
    </member>
    <member name="M:CatLibrary.ICat.CatchJerry">
      <summary>
            All cat can catch a Jerry.</summary>
    </member>
    <member name="T:CatLibrary.ICatExtension">
      <summary>
            It's the class that contains ICat interface's extension method.
            <para>This class must be public and static.</para><para>Also it shouldn't be a geneic class</para></summary>
    </member>
    <member name="M:CatLibrary.ICatExtension.Play(CatLibrary.ICat,System.String)">
      <summary>
            Extension method to let cat play</summary>
      <param name="icat">Cat</param>
      <param name="toy">Something to play</param>
    </member>
    <member name="M:CatLibrary.ICatExtension.Sleep(CatLibrary.ICat,System.Int64)">
      <summary>
            Extension method hint that how long the cat can sleep.</summary>
      <param name="icat">The type will be extended.</param>
      <param name="hours">The length of sleep.</param>
    </member>
    <member name="T:CatLibrary.JerryExtension">
      <summary>
            This class extends <see cref="T:CatLibrary.TomFromBaseClass.Jerry" />.</summary>
    </member>
    <member name="M:CatLibrary.JerryExtension.PlayWith(CatLibrary.TomFromBaseClass.Jerry,CatLibrary.Tom)">
      <summary>
            Jerry can play with a Tom.</summary>
      <param name="jerry" />
      <param name="tom" />
    </member>
    <member name="T:CatLibrary.MRefDelegate`3">
      <summary>
            Generic delegate with many constrains.</summary>
      <param name="k">Type K.</param>
      <param name="t">Type T.</param>
      <param name="l">Type L.</param>
      <typeparam name="K">Generic K.</typeparam>
      <typeparam name="T">Generic T.</typeparam>
      <typeparam name="L">Generic L.</typeparam>
    </member>
    <member name="T:CatLibrary.MRefNormalDelegate">
      <summary>
            Delegate in the namespace</summary>
      <param name="pics">a name list of pictures.</param>
      <param name="name">give out the needed name.</param>
    </member>
    <member name="T:CatLibrary.Tom">
      <summary>
            Tom class is only inherit from Object. Not any member inside itself.</summary>
    </member>
    <member name="M:CatLibrary.Tom.#ctor" />
    <member name="M:CatLibrary.Tom.TomMethod(CatLibrary.Complex{CatLibrary.TomFromBaseClass,CatLibrary.TomFromBaseClass},System.Tuple{System.String,CatLibrary.Tom})">
      <summary>
            This is a Tom Method with complex type as return</summary>
      <param name="a">A complex input</param>
      <param name="b">Another complex input</param>
      <exception cref="T:System.NotImplementedException">This is not implemented</exception>
      <exception cref="T:System.ArgumentException">This is the exception to be thrown when implemented</exception>
      <exception cref="T:CatLibrary.CatException`1">This is the exception in current documentation</exception>
      <returns>Complex @CatLibrary.TomFromBaseClass</returns>
    </member>
    <member name="T:CatLibrary.TomFromBaseClass">
      <summary>
            TomFromBaseClass inherits from @CatLibrary.Tom</summary>
    </member>
    <member name="M:CatLibrary.TomFromBaseClass.#ctor(System.Int32)">
      <summary>
            This is a #ctor with parameter</summary>
      <param name="k" />
    </member>
    <member name="T:CatLibrary.TomFromBaseClass.Jerry">
      <summary>
            This is a nested class inside <see cref="T:CatLibrary.TomFromBaseClass" /></summary>
    </member>
    <member name="M:CatLibrary.TomFromBaseClass.Jerry.#ctor(MRef.Demo.Enumeration.ColorType)">
      <summary>
            Jerry has different <see cref="T:MRef.Demo.Enumeration.ColorType">colors</see>.</summary>
      <param name="color">Color of Jerry.</param>
    </member>
    <member name="T:VersioningTest.A" />
    <member name="M:VersioningTest.A.#ctor" />
    <member name="M:VersioningTest.A.MethodFromClassA(System.String)">
      <summary>
            this method should show up as inherited member in class D only for cat-1.0</summary>
      <param name="param1" />
    </member>
    <member name="T:VersioningTest.B" />
    <member name="M:VersioningTest.B.#ctor" />
    <member name="M:VersioningTest.B.MethodFromClassB(System.String)">
      <summary>
            this method should show up as inherited member in class D/F/G/H only for cat-2.0</summary>
      <param name="param1" />
    </member>
    <member name="T:VersioningTest.C" />
    <member name="M:VersioningTest.C.#ctor" />
    <member name="M:VersioningTest.C.MethodForI">
      <summary>
            This method was moved from I1 to I2.</summary>
    </member>
    <member name="T:VersioningTest.D" />
    <member name="M:VersioningTest.D.#ctor" />
    <member name="T:VersioningTest.E" />
    <member name="M:VersioningTest.E.#ctor" />
    <member name="T:VersioningTest.F">
      <summary>
            class F should has two inheritance chains: C for cat-1.0, and B -&gt; D for cat-2.0.</summary>
    </member>
    <member name="M:VersioningTest.F.#ctor" />
    <member name="T:VersioningTest.G" />
    <member name="M:VersioningTest.G.#ctor" />
    <member name="T:VersioningTest.H" />
    <member name="M:VersioningTest.H.#ctor" />
    <member name="T:VersioningTest.I2" />
    <member name="M:VersioningTest.I2.MethodForI">
      <summary>
            This method was moved from I1 to I2.</summary>
    </member>
    <member name="T:VersioningTest.VersioningExtensions" />
    <member name="M:VersioningTest.VersioningExtensions.ExtMethodForD(VersioningTest.D)">
      <summary>
            this extension method should show up in class D for all monikers, and in F/G/H for cat-2.0 only.</summary>
      <param name="i" />
    </member>
    <member name="M:VersioningTest.VersioningExtensions.ExtMethodForI(VersioningTest.I2)">
      <summary>
            this extension method should show up in interface <c>I2</c>, class <c>C</c> and <c>E</c> for all monikers, and in F/G/H for cat-2.0 only.</summary>
      <param name="i" />
    </member>
  </members>
</doc>